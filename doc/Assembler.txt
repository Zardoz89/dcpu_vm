DCPU-16 Bin assembler
Author : Lamogui
=========================================================

The DCPU-16 Bin assembler support common symbol of 
assembly languages, and all the DCPU-16 instructions.

I.Btarget
=========
The btarget is the place were the result of the instruction 
will be placed, or the target to compare in comparative
instructions : it can be a register or a pointer.
Register are : A,B,C,X,Y,Z,I,J,PC,SP,EX.
There is special target PUSH (from the stack) 

II.Avalue
=========
The avalue is the value associated to the instruction, it
can be a litteral value, a value get from a pointer or a 
value contained by a register.

III.Pointer
===========
To declare a pointer you must use the syntax [pointer].
Bin assembler support the '+' operator then you can put
multiples litteral value/labels in the pointer section.
You can also add a register (only A,B,C,X,Y,Z,I or J)
on the pointer value. 

IV.Basic Instructions
====================

A basic instruction is an instruction which requiert 2
informations : the "btarget" and the "avalue".
They are : comparatives instructions, placement 
instructions, affectation instructions and mathematical 
instructions.

Here the official list from the DCPU-16 spec:
 C | VAL  | NAME     | DESCRIPTION
---+------+----------+--------------------------------
 - | 0x00 | n/a      | special instruction - see below
 1 | 0x01 | SET b, a | sets b to a
 2 | 0x02 | ADD b, a | sets b to b+a
 2 | 0x03 | SUB b, a | sets b to b-a
 2 | 0x04 | MUL b, a | sets b to b*a(treats b and a 
   |      |          | as unsigned)
 2 | 0x05 | MLI b, a | like MUL, but treat b, a as signed
 3 | 0x06 | DIV b, a | sets b to b/a,(treats b, a as unsigned)
 3 | 0x07 | DVI b, a | like DIV, but treat b, a as signed. Rounds towards 0
 3 | 0x08 | MOD b, a | sets b to b%a.
 3 | 0x09 | MDI b, a | like MOD, but treat b, a as signed. (MDI -7, 16 == -7)
 1 | 0x0a | AND b, a | sets b to b&a
 1 | 0x0b | BOR b, a | sets b to b|a
 1 | 0x0c | XOR b, a | sets b to b^a
 1 | 0x0d | SHR b, a | sets b to b>>>a, sets EX to ((b<<16)>>a)&0xffff 
   |      |          | (logical shift)
 1 | 0x0e | ASR b, a | sets b to b>>a, sets EX to ((b<<16)>>>a)&0xffff 
   |      |          | (arithmetic shift) (treats b as signed)
 1 | 0x0f | SHL b, a | sets b to b<<a, sets EX to ((b<<a)>>16)&0xffff
 2+| 0x10 | IFB b, a | performs next instruction only if (b&a)!=0
 2+| 0x11 | IFC b, a | performs next instruction only if (b&a)==0
 2+| 0x12 | IFE b, a | performs next instruction only if b==a 
 2+| 0x13 | IFN b, a | performs next instruction only if b!=a 
 2+| 0x14 | IFG b, a | performs next instruction only if b>a 
 2+| 0x15 | IFA b, a | performs next instruction only if b>a (signed)
 2+| 0x16 | IFL b, a | performs next instruction only if b<a 
 2+| 0x17 | IFU b, a | performs next instruction only if b<a (signed)
 - | 0x18 | -        |
 - | 0x19 | -        |
 3 | 0x1a | ADX b, a | sets b to b+a+EX, sets EX to 0x0001 if there is an over-
   |      |          | flow, 0x0 otherwise
 3 | 0x1b | SBX b, a | sets b to b-a+EX, sets EX to 0xFFFF if there is an under-
   |      |          | flow, 0x0001 if there's an overflow, 0x0 otherwise
 - | 0x1c | -        | 
 - | 0x1d | -        |
 2 | 0x1e | STI b, a | sets b to a, then increases I and J by 1
 2 | 0x1f | STD b, a | sets b to a, then decreases I and J by 1
---+------+----------+---------------------------------






